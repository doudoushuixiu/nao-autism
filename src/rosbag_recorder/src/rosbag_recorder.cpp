#include <rosbag_recorder.h>
#include <geometry_msgs/TransformStamped.h>
#include <geometry_msgs/Transform.h>
#include <geometry_msgs/Quaternion.h>

#include <time.h>
#include <boost/thread.hpp>
#include <boost/foreach.hpp>
#include <boost/filesystem.hpp>
#include <vector>

bool recordingRaw, recordingRgb, bagClosed;

/**
  * Constructor.
  */
RosbagRecorder::RosbagRecorder(void) : node(), rate(10.0)
{
	// Create folder to put bagfiles in
	std::string foldername = "recordings/" + currentDateTime();
	init(foldername);
}

/**
  * Constructor.
  */
RosbagRecorder::RosbagRecorder(std::string emotion) : node(), rate(10.0)
{
	// Create folder to put bagfiles in
	std::string foldername = "recordings/" + emotion + "-" + currentDateTime();
	init(foldername);
}

void RosbagRecorder::init(std::string foldername)
{
	boost::filesystem::path dir(foldername);
	boost::filesystem::create_directories(dir);	
	
	raw_bag = new rosbag::Bag(foldername + "/raw.bag", rosbag::bagmode::Write);
	//rotations_bag = new rosbag::Bag(foldername + "/rotations.bag", rosbag::bagmode::Write);
	
	ros::Time::init();
}

RosbagRecorder::~RosbagRecorder(void)
{
	std::cout << "Dying!" << std::endl;
	delete raw_bag;
	//delete rotations_bag;
}

RosbagRecorder *RosbagRecorder::createRecorder(std::string emotionName)
{
	RosbagRecorder *recorder = new RosbagRecorder(emotionName);
	return recorder;
}

/**
  * Start recording data in two threads: raw and joint relationships.
  */
RosbagRecorder *RosbagRecorder::record(std::string emotionName)
{	
	//if (!n.ok()) ros::start();
	
	std::cout << "Creating recorder..." << std::endl;
	
	RosbagRecorder *recorder = RosbagRecorder::createRecorder(emotionName);
	
	boost::thread t1(&RosbagRecorder::recordRaw, recorder);
	boost::thread t2(&RosbagRecorder::recordRgb, recorder);
	
	return recorder;
}

void RosbagRecorder::stop(void)
{
	stopped = true;
}

/**
  * Records the raw data generated by openni_tracker (same as command line 'rosbag record tf').
  */
void RosbagRecorder::recordRaw(void)
{
	ros::Subscriber sub = node.subscribe("/tf", 1000, &RosbagRecorder::recordCallback, this);
	recordingRaw = true;
	
	ros::Rate rate(10.0);
	while (!stopped) {
		ros::spinOnce();
		rate.sleep();
	}
	
	recordingRaw = false;
	
	if (!recordingRgb && !bagClosed) {
		raw_bag->close();
		bagClosed = true;
	}
}

void RosbagRecorder::recordRgb(void)
{
	ros::Subscriber sub = node.subscribe("camera/rgb/image_color", 1000, &RosbagRecorder::rgbCallback, this);
	recordingRgb = true;

	ros::Rate rate(1);
	while (!stopped) {
		ros::spinOnce();
		rate.sleep();
	}

	recordingRgb = false;

	if (!recordingRaw && !bagClosed) {
		raw_bag->close();
		bagClosed = true;
	}
}

void RosbagRecorder::recordPointCloud(void)
{
	ros::Subscriber sub = node.subscribe("camera/depth/image_raw", 1000,
			&RosbagRecorder::pointCloudCallback, this);
	recordingRgb = true;

	ros::Rate rate(1);
	while (!stopped) {
		ros::spinOnce();
		rate.sleep();
	}

	recordingRgb = false;

	if (!recordingRaw && !bagClosed) {
		raw_bag->close();
		bagClosed = true;
	}
}

/**
  * Records only the relevant joint relationships for the machine learning algorithm:
  * hand-elbow, hand-shoulder, hand-head, hand-torso, elbow-shoulder, elbow-head,
  * elbow-torso. Currently unused.
  */
/*void RosbagRecorder::recordRotations(void)
{
	while (node.ok()) {
		std::vector<tf::StampedTransform> transforms(14);

		// TODO: make this a method accepting 2 strings as input
		try {
        	listener.lookupTransform("/left_hand_1", "/left_elbow_1", ros::Time(0), transforms[0]);
        	listener.lookupTransform("/left_hand_1", "/left_shoulder_1", ros::Time(0), transforms[1]);
        	listener.lookupTransform("/left_hand_1", "/head_1", ros::Time(0), transforms[2]);
        	listener.lookupTransform("/left_hand_1", "/torso_1", ros::Time(0), transforms[3]);
        	listener.lookupTransform("/left_elbow_1", "/left_shoulder_1", ros::Time(0), transforms[4]);
			listener.lookupTransform("/left_elbow_1", "/head_1", ros::Time(0), transforms[5]);
			listener.lookupTransform("/left_elbow_1", "/torso_1", ros::Time(0), transforms[6]);
		
			listener.lookupTransform("/right_hand_1", "/right_elbow_1", ros::Time(0), transforms[7]);
        	listener.lookupTransform("/right_hand_1", "/right_shoulder_1", ros::Time(0), transforms[8]);
        	listener.lookupTransform("/right_hand_1", "/head_1", ros::Time(0), transforms[9]);
        	listener.lookupTransform("/right_hand_1", "/torso_1", ros::Time(0), transforms[10]);
        	listener.lookupTransform("/right_elbow_1", "/right_shoulder_1", ros::Time(0), transforms[11]);
			listener.lookupTransform("/right_elbow_1", "/head_1", ros::Time(0), transforms[12]);
			listener.lookupTransform("/right_elbow_1", "/torso_1", ros::Time(0), transforms[13]);        
		}
		catch (tf::TransformException ex) {
			ROS_ERROR("%s", ex.what());
		}
	
		// Write all the generated messages to the rotations bagfile
		BOOST_FOREACH(tf::StampedTransform transform, transforms) {
			// Create parts of tfMessage to write
    		geometry_msgs::TransformStamped msg;
    		std::vector<geometry_msgs::TransformStamped>vec_msg;
			tf::tfMessage tfmsg;
		
			// Assemble parts into a tfMessage
			tf::transformStampedTFToMsg(transform, msg);
			vec_msg.push_back(msg);
			tfmsg.transforms = vec_msg;
		
			rotations_bag->write("/tf", ros::Time::now(), tfmsg);
		}
		
		rate.sleep();
	}
        
	rotations_bag->close();
}*/

/**
  * Called by RosbagRecorder::recordRaw(). Gets a tf::tfMessage (generated
  * by openni_tracker) and writes it to the raw bagfile.
  */
void RosbagRecorder::recordCallback(const tf::tfMessage::ConstPtr& msg)
{
	geometry_msgs::TransformStamped fullTransform = (msg->transforms)[0];
				
	// Only deal with transforms from joints (not camera frame transforms)
	if (fullTransform.child_frame_id.find("camera") == std::string::npos) {
        raw_bag->write("/tf", ros::Time::now(), *msg);
	}
}

void RosbagRecorder::rgbCallback(const sensor_msgs::Image::ConstPtr& msg)
{
	raw_bag->write("camera/rgb/image_raw", ros::Time::now(), *msg);
}

void RosbagRecorder::pointCloudCallback(const sensor_msgs::Image::ConstPtr& msg)
{

}

/**
  * Gets the current date and time in a std::string.
  */
const std::string RosbagRecorder::currentDateTime(void) {
    time_t     now = time(0);
    struct tm  tstruct;
    char       buf[80];
    tstruct = *localtime(&now);
    
    strftime(buf, sizeof(buf), "%Y-%m-%d.%X", &tstruct);

    return buf;
}


int main(int argc, char *argv[]) {
	ros::init(argc, argv, "rosbag_recorder");
	
	/*if (argc > 1)
		recorder = new RosbagRecorder(argv[1]);
	else
		recorder = new RosbagRecorder();*/
		
	
	RosbagRecorder *recorder = RosbagRecorder::record("happy");
	sleep(30);
	recorder->stop();
	
	std::cout << "Program finished." << std::endl;

	return 0;
}

