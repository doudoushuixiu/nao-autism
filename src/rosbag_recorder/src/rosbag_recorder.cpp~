#include <rosbag_recorder.h>
#include <geometry_msgs/TransformStamped.h>
#include <geometry_msgs/Transform.h>
#include <geometry_msgs/Quaternion.h>

#include <time.h>
#include <boost/thread.hpp>
#include <boost/foreach.hpp>
#include <boost/filesystem.hpp>
#include <vector>

/**
  * Constructor.
  */
RosbagRecorder::RosbagRecorder(void) : n(), listener(), rate(10.0)
{
	// Create folder to put bagfiles in
	std::string foldername = currentDateTime();
	boost::filesystem::path dir(foldername);
	boost::filesystem::create_directory(dir);	
	
	raw_bag = new rosbag::Bag(foldername + "/raw.bag", rosbag::bagmode::Write);
	rotations_bag = new rosbag::Bag(foldername + "/rotations.bag", rosbag::bagmode::Write);
	
	ros::Time::init();
}

/**
  * Start recording data in two threads: raw and joint relationships.
  */
void RosbagRecorder::record(void)
{	
	if (!n.ok()) ros::start();
	
	boost::thread t1(&RosbagRecorder::recordRaw, this);
	boost::thread t2(&RosbagRecorder::recordRotations, this);
	t1.join();
	t2.join();
}

void RosbagRecorder::stop(void)
{
	ros::shutdown();
}

/**
  * Records the raw data generated by openni_tracker (same as command line 'rosbag record tf').
  */
void RosbagRecorder::recordRaw(void)
{
	ros::Subscriber sub = n.subscribe("/tf", 1000, &RosbagRecorder::recordCallback, this);
	ros::spin();
	
	raw_bag->close();
}

/**
  * Records only the relevant joint relationships for the machine learning algorithm:
  * hand-elbow, hand-shoulder, hand-head, hand-torso, elbow-shoulder, elbow-head,
  * elbow-torso.
  */
void RosbagRecorder::recordRotations(void)
{
	while (n.ok()) {
		std::vector<tf::StampedTransform> transforms(14);

		// TODO: make this a method accepting 2 strings as input
		try {
        	listener.lookupTransform("/left_hand_1", "/left_elbow_1", ros::Time(0), transforms[0]);
        	listener.lookupTransform("/left_hand_1", "/left_shoulder_1", ros::Time(0), transforms[1]);
        	listener.lookupTransform("/left_hand_1", "/head_1", ros::Time(0), transforms[2]);
        	listener.lookupTransform("/left_hand_1", "/torso_1", ros::Time(0), transforms[3]);
        	listener.lookupTransform("/left_elbow_1", "/left_shoulder_1", ros::Time(0), transforms[4]);
			listener.lookupTransform("/left_elbow_1", "/head_1", ros::Time(0), transforms[5]);
			listener.lookupTransform("/left_elbow_1", "/torso_1", ros::Time(0), transforms[6]);
		
			listener.lookupTransform("/right_hand_1", "/right_elbow_1", ros::Time(0), transforms[7]);
        	listener.lookupTransform("/right_hand_1", "/right_shoulder_1", ros::Time(0), transforms[8]);
        	listener.lookupTransform("/right_hand_1", "/head_1", ros::Time(0), transforms[9]);
        	listener.lookupTransform("/right_hand_1", "/torso_1", ros::Time(0), transforms[10]);
        	listener.lookupTransform("/right_elbow_1", "/right_shoulder_1", ros::Time(0), transforms[11]);
			listener.lookupTransform("/right_elbow_1", "/head_1", ros::Time(0), transforms[12]);
			listener.lookupTransform("/right_elbow_1", "/torso_1", ros::Time(0), transforms[13]);        
		}
		catch (tf::TransformException ex) {
			ROS_ERROR("%s", ex.what());
		}
	
		// Write all the generated messages to the rotations bagfile
		BOOST_FOREACH(tf::StampedTransform transform, transforms) {
			// Create parts of tfMessage to write
    		geometry_msgs::TransformStamped msg;
    		std::vector<geometry_msgs::TransformStamped>vec_msg;
			tf::tfMessage tfmsg;
		
			// Assemble parts into a tfMessage
			tf::transformStampedTFToMsg(transform, msg);
			vec_msg.push_back(msg);
			tfmsg.transforms = vec_msg;
		
			rotations_bag->write("/tf", ros::Time::now(), tfmsg);
		}
		
		rate.sleep();
	}
        
	rotations_bag->close();
}

/**
  * Called by RosbagRecorder::recordRaw(). Gets a tf::tfMessage (generated
  * by openni_tracker) and writes it to the raw bagfile.
  */
void RosbagRecorder::recordCallback(const tf::tfMessage::ConstPtr& msg)
{
	geometry_msgs::TransformStamped fullTransform = (msg->transforms)[0];
				
	// Only deal with transforms from joints (not camera frame transforms)
	if (fullTransform.child_frame_id.find("camera") == std::string::npos) { 
		//geometry_msgs::Transform transform = fullTransform.transform;
        //geometry_msgs::Quaternion transQt = transform.rotation;

		//std::cout << "Frame id: " << fullTransform.child_frame_id << std::endl;
        //std::cout << fullTransform << std::endl;
        raw_bag->write("/tf", ros::Time::now(), *msg);
	}
}

/**
  * Gets the current date and time in a std::string.
  */
const std::string RosbagRecorder::currentDateTime(void) {
    time_t     now = time(0);
    struct tm  tstruct;
    char       buf[80];
    tstruct = *localtime(&now);
    
    strftime(buf, sizeof(buf), "%Y-%m-%d.%X", &tstruct);

    return buf;
}


int main(int argc, char **argv) {
	ros::init(argc, argv, "rosbag_recorder");
	
	RosbagRecorder recorder;
	
	printf("Press 'r' to record");
	std::string input = "";
	std::getline(std::cin, input);
	
	if (input == "r")
		recorder.record();
	
	printf("Press 's' to stop");
	input = "";
	std::getline(std::cin, input);
	
	if (input == "s")
		recorder.stop();
		
	printf("Press 'r' to record");
	input = "";
	std::getline(std::cin, input);
	
	if (input == "r")
		recorder.record();

	return 0;
}

